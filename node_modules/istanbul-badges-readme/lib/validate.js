"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkConfig = exports.doestReadmeHashExist = exports.doesCoverageHashesExist = exports.doesCoverageFileExist = exports.doesReadmeFileExist = exports.getCoveragePath = void 0;
const fs_1 = __importDefault(require("fs"));
const arguments_1 = require("./arguments");
const constants_1 = require("./constants");
const logger_1 = require("./logger");
const { logInfo } = logger_1.logger();
const getCoveragePath = (path) => {
    let coveragePath = path;
    const argPath = arguments_1.getArgumentValue('coverageDir');
    if (argPath) {
        coveragePath = `${argPath}/coverage-summary.json`;
    }
    return coveragePath;
};
exports.getCoveragePath = getCoveragePath;
const doesReadmeFileExist = (readmePath) => {
    return new Promise((resolve, reject) => {
        const doesItExist = fs_1.default.existsSync(readmePath);
        if (doesItExist)
            return resolve(true);
        return reject('Readme file does not exist');
    });
};
exports.doesReadmeFileExist = doesReadmeFileExist;
const doesCoverageFileExist = (coveragePath) => {
    return new Promise((resolve, reject) => {
        const currentCoveragePath = exports.getCoveragePath(coveragePath);
        const doesItExist = fs_1.default.existsSync(currentCoveragePath);
        if (doesItExist)
            return resolve(true);
        return reject(`Coverage file does not exist in ${currentCoveragePath}`);
    });
};
exports.doesCoverageFileExist = doesCoverageFileExist;
const doesCoverageHashesExist = (coveragePath) => {
    return new Promise((resolve, reject) => {
        const coverageFile = fs_1.default.readFileSync(coveragePath);
        constants_1.hashesConst.coverage.forEach((hash) => {
            if (coverageFile.includes(hash.key))
                return resolve(true);
        });
        return reject('Coverage file does contain the needed hashes');
    });
};
exports.doesCoverageHashesExist = doesCoverageHashesExist;
const doestReadmeHashExist = (readmePath) => {
    return new Promise((resolve, reject) => {
        const readmeFile = fs_1.default.readFileSync(readmePath);
        constants_1.hashesConst.coverage.forEach((hash) => {
            if (readmeFile.includes(`![${hash.value}]`))
                return resolve(true);
        });
        return reject('Readme does not contain the needed hashes');
    });
};
exports.doestReadmeHashExist = doestReadmeHashExist;
const checkConfig = () => {
    logInfo('Info: 1. Config check process started');
    return exports.doesReadmeFileExist(constants_1.readmePathConst)
        .then(() => {
        logInfo('- Readme file exists... ✔️.');
    })
        .then(() => exports.doesCoverageFileExist(constants_1.coveragePathConst))
        .then(() => {
        logInfo('- Coverage file exists... ✔️.');
    })
        .then(() => exports.doesCoverageHashesExist(constants_1.coveragePathConst))
        .then(() => {
        logInfo('- Coverage hashes exist... ✔️.');
    })
        .then(() => exports.doestReadmeHashExist(constants_1.readmePathConst))
        .then(() => {
        logInfo('- Readme hashes exist... ✔️.');
    })
        .then(() => logInfo('Info: 1. Config check process ended'));
};
exports.checkConfig = checkConfig;
