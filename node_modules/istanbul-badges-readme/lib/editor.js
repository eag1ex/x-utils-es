"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.editReadme = exports.writeNewReadme = exports.getNewReadme = exports.getCoverageBadge = exports.getCoverageColor = exports.getReadmeHashes = void 0;
const fs_1 = __importDefault(require("fs"));
const constants_1 = require("./constants");
const logger_1 = require("./logger");
const { logInfo } = logger_1.logger();
const getReadmeHashes = (readmeFile) => {
    logInfo('- Getting readme hashes...');
    const readmeHashes = constants_1.hashesConst.coverage.map((hash) => {
        if (readmeFile.includes(`![${hash.value}]`)) {
            return hash;
        }
        return false;
    });
    const filteredHashes = readmeHashes.filter(Boolean);
    return filteredHashes;
};
exports.getReadmeHashes = getReadmeHashes;
const getCoverageColor = (coverage) => {
    if (coverage < 80) {
        return 'red';
    }
    if (coverage < 90) {
        return 'yellow';
    }
    return 'brightgreen';
};
exports.getCoverageColor = getCoverageColor;
const getCoverageBadge = (coverageFile, hashKey) => {
    logInfo(`- Getting coverage badge url for ${hashKey}...`);
    try {
        const parsedCoverage = JSON.parse(coverageFile);
        if (!parsedCoverage.total && parsedCoverage.total[hashKey]) {
            return false;
        }
        const coverage = parsedCoverage.total[hashKey].pct;
        const color = exports.getCoverageColor(coverage);
        return constants_1.coverageUrlConst(coverage, color);
    }
    catch (_a) {
        return false;
    }
};
exports.getCoverageBadge = getCoverageBadge;
const getNewReadme = (readmeFile, coverageFile) => (readmeHashes) => {
    logInfo('- Getting new readme data...');
    let newReadmeFile = readmeFile;
    return new Promise((resolve, reject) => {
        readmeHashes.forEach((hash) => {
            const coverageBadge = exports.getCoverageBadge(coverageFile, hash.key);
            if (!coverageBadge) {
                reject('There has been an error getting new coverage badges');
            }
            const pattern = `![${hash.value}]`;
            const enpatterned = (value) => `${pattern}(${value})`;
            const startIndex = newReadmeFile.indexOf(pattern);
            const valueToChangeStart = newReadmeFile.slice(startIndex + pattern.length);
            const valueToChangeIndex = valueToChangeStart.indexOf(')');
            const valueToChangeFinal = valueToChangeStart.substring(1, valueToChangeIndex);
            newReadmeFile = newReadmeFile.replace(enpatterned(valueToChangeFinal), enpatterned(coverageBadge));
        });
        resolve(newReadmeFile);
    });
};
exports.getNewReadme = getNewReadme;
const writeNewReadme = (readmePath) => (newReadmeData) => {
    logInfo('- Writing new readme data...');
    try {
        return fs_1.default.writeFileSync(readmePath, newReadmeData, 'utf8');
    }
    catch (_a) {
        return false;
    }
};
exports.writeNewReadme = writeNewReadme;
const editReadme = () => {
    logInfo('Info: 2. Editor process started');
    const readmeFile = fs_1.default.readFileSync(constants_1.readmePathConst, 'utf-8');
    const coverageFile = fs_1.default.readFileSync(constants_1.coveragePathConst, 'utf8');
    return Promise.resolve(readmeFile)
        .then(exports.getReadmeHashes)
        .then(exports.getNewReadme(readmeFile, coverageFile))
        .then(exports.writeNewReadme(constants_1.readmePathConst))
        .then(() => logInfo('Info: 2. Editor process ended'));
};
exports.editReadme = editReadme;
