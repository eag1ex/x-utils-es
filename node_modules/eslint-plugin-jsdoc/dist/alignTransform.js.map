{"version":3,"sources":["../src/alignTransform.js"],"names":["zeroWidth","name","start","tag","type","shouldAlign","tags","index","source","tokens","replace","includesTag","includes","iterator","previousTag","getWidth","width","Math","max","length","delimiter","Markers","space","len","padStart","alignTransform","indent","intoTags","alignTokens","nothingAfter","delim","description","postName","postType","postTag","postDelimiter","update","line","isEmpty","end","fields","reduce","map"],"mappings":";;;;;;;AAAA;;AAGA;;AAIA,MAAMA,SAAS,GAAG;AAChBC,EAAAA,IAAI,EAAE,CADU;AAEhBC,EAAAA,KAAK,EAAE,CAFS;AAGhBC,EAAAA,GAAG,EAAE,CAHW;AAIhBC,EAAAA,IAAI,EAAE;AAJU,CAAlB;;AAOA,MAAMC,WAAW,GAAG,CAACC,IAAD,EAAOC,KAAP,EAAcC,MAAd,KAAyB;AAC3C,QAAML,GAAG,GAAGK,MAAM,CAACD,KAAD,CAAN,CAAcE,MAAd,CAAqBN,GAArB,CAAyBO,OAAzB,CAAiC,GAAjC,EAAsC,EAAtC,CAAZ;AACA,QAAMC,WAAW,GAAGL,IAAI,CAACM,QAAL,CAAcT,GAAd,CAApB;;AAEA,MAAIQ,WAAJ,EAAiB;AACf,WAAO,IAAP;AACD;;AAED,MAAIR,GAAG,KAAK,EAAZ,EAAgB;AACd,WAAO,KAAP;AACD;;AAED,OAAK,IAAIU,QAAQ,GAAGN,KAApB,EAA2BM,QAAQ,IAAI,CAAvC,EAA0CA,QAAQ,EAAlD,EAAsD;AACpD,UAAMC,WAAW,GAAGN,MAAM,CAACK,QAAD,CAAN,CAAiBJ,MAAjB,CAAwBN,GAAxB,CAA4BO,OAA5B,CAAoC,GAApC,EAAyC,EAAzC,CAApB;;AAEA,QAAII,WAAW,KAAK,EAApB,EAAwB;AACtB,UAAIR,IAAI,CAACM,QAAL,CAAcE,WAAd,CAAJ,EAAgC;AAC9B,eAAO,IAAP;AACD;;AAED,aAAO,KAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD,CAzBD;;AA2BA,MAAMC,QAAQ,GAAIT,IAAD,IAAU;AACzB,SAAO,CAACU,KAAD,EAAQ;AAACP,IAAAA;AAAD,GAAR,EAAkBF,KAAlB,EAAyBC,MAAzB,KAAoC;AACzC,QAAI,CAACH,WAAW,CAACC,IAAD,EAAOC,KAAP,EAAcC,MAAd,CAAhB,EAAuC;AACrC,aAAOQ,KAAP;AACD;;AAED,WAAO;AACLf,MAAAA,IAAI,EAAEgB,IAAI,CAACC,GAAL,CAASF,KAAK,CAACf,IAAf,EAAqBQ,MAAM,CAACR,IAAP,CAAYkB,MAAjC,CADD;AAELjB,MAAAA,KAAK,EAAEO,MAAM,CAACW,SAAP,KAAqBC,oBAAQnB,KAA7B,GAAqCO,MAAM,CAACP,KAAP,CAAaiB,MAAlD,GAA2DH,KAAK,CAACd,KAFnE;AAGLC,MAAAA,GAAG,EAAEc,IAAI,CAACC,GAAL,CAASF,KAAK,CAACb,GAAf,EAAoBM,MAAM,CAACN,GAAP,CAAWgB,MAA/B,CAHA;AAILf,MAAAA,IAAI,EAAEa,IAAI,CAACC,GAAL,CAASF,KAAK,CAACZ,IAAf,EAAqBK,MAAM,CAACL,IAAP,CAAYe,MAAjC;AAJD,KAAP;AAMD,GAXD;AAYD,CAbD;;AAeA,MAAMG,KAAK,GAAIC,GAAD,IAAS;AACrB,SAAO,GAAGC,QAAH,CAAYD,GAAZ,EAAiB,GAAjB,CAAP;AACD,CAFD;;AAIA,MAAME,cAAc,GAAG,CAACnB,IAAD,EAAOoB,MAAP,KAAkB;AACvC,MAAIC,QAAQ,GAAG,KAAf;AACA,MAAIX,KAAJ;;AAEA,QAAMY,WAAW,GAAInB,MAAD,IAAY;AAC9B,UAAMoB,YAAY,GAAG;AACnBC,MAAAA,KAAK,EAAE,KADY;AAEnB7B,MAAAA,IAAI,EAAE,KAFa;AAGnBE,MAAAA,GAAG,EAAE,KAHc;AAInBC,MAAAA,IAAI,EAAE;AAJa,KAArB;;AAOA,QAAIK,MAAM,CAACsB,WAAP,KAAuB,EAA3B,EAA+B;AAC7BF,MAAAA,YAAY,CAAC5B,IAAb,GAAoB,IAApB;AACAQ,MAAAA,MAAM,CAACuB,QAAP,GAAkB,EAAlB;;AAEA,UAAIvB,MAAM,CAACR,IAAP,KAAgB,EAApB,EAAwB;AACtB4B,QAAAA,YAAY,CAACzB,IAAb,GAAoB,IAApB;AACAK,QAAAA,MAAM,CAACwB,QAAP,GAAkB,EAAlB;;AAEA,YAAIxB,MAAM,CAACL,IAAP,KAAgB,EAApB,EAAwB;AACtByB,UAAAA,YAAY,CAAC1B,GAAb,GAAmB,IAAnB;AACAM,UAAAA,MAAM,CAACyB,OAAP,GAAiB,EAAjB;AAEA;;AACA,cAAIzB,MAAM,CAACN,GAAP,KAAe,EAAnB,EAAuB;AACrB0B,YAAAA,YAAY,CAACC,KAAb,GAAqB,IAArB;AACD;AACF;AACF;AACF;;AAEDrB,IAAAA,MAAM,CAAC0B,aAAP,GAAuBN,YAAY,CAACC,KAAb,GAAqB,EAArB,GAA0B,GAAjD;;AAEA,QAAI,CAACD,YAAY,CAAC1B,GAAlB,EAAuB;AACrBM,MAAAA,MAAM,CAACyB,OAAP,GAAiBZ,KAAK,CAACN,KAAK,CAACb,GAAN,GAAYM,MAAM,CAACN,GAAP,CAAWgB,MAAvB,GAAgC,CAAjC,CAAtB;AACD;;AACD,QAAI,CAACU,YAAY,CAACzB,IAAlB,EAAwB;AACtBK,MAAAA,MAAM,CAACwB,QAAP,GAAkBX,KAAK,CAACN,KAAK,CAACZ,IAAN,GAAaK,MAAM,CAACL,IAAP,CAAYe,MAAzB,GAAkC,CAAnC,CAAvB;AACD;;AACD,QAAI,CAACU,YAAY,CAAC5B,IAAlB,EAAwB;AACtB;AACAQ,MAAAA,MAAM,CAACuB,QAAP,GAAkBhB,KAAK,CAACf,IAAN,KAAe,CAAf,GAAmB,EAAnB,GAAwBqB,KAAK,CAACN,KAAK,CAACf,IAAN,GAAaQ,MAAM,CAACR,IAAP,CAAYkB,MAAzB,GAAkC,CAAnC,CAA/C;AACD;;AAED,WAAOV,MAAP;AACD,GA1CD;;AA4CA,QAAM2B,MAAM,GAAG,CAACC,IAAD,EAAO9B,KAAP,EAAcC,MAAd,KAAyB;AACtC,UAAMC,MAAM,GAAG,EAAC,GAAG4B,IAAI,CAAC5B;AAAT,KAAf;;AACA,QAAIA,MAAM,CAACN,GAAP,KAAe,EAAnB,EAAuB;AACrBwB,MAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,UAAMW,OAAO,GACX7B,MAAM,CAACN,GAAP,KAAe,EAAf,IACAM,MAAM,CAACR,IAAP,KAAgB,EADhB,IAEAQ,MAAM,CAACL,IAAP,KAAgB,EAFhB,IAGAK,MAAM,CAACsB,WAAP,KAAuB,EAJzB,CANsC,CAYtC;;AACA,QAAItB,MAAM,CAAC8B,GAAP,KAAelB,oBAAQkB,GAAvB,IAA8BD,OAAlC,EAA2C;AACzC7B,MAAAA,MAAM,CAACP,KAAP,GAAewB,MAAM,GAAG,GAAxB;AAEA,aAAO,EACL,GAAGW,IADE;AAEL5B,QAAAA;AAFK,OAAP;AAID;AAED;;;AACA,YAAQA,MAAM,CAACW,SAAf;AACE,WAAKC,oBAAQnB,KAAb;AACEO,QAAAA,MAAM,CAACP,KAAP,GAAewB,MAAf;AACA;;AACF,WAAKL,oBAAQS,KAAb;AACErB,QAAAA,MAAM,CAACP,KAAP,GAAewB,MAAM,GAAG,GAAxB;AACA;;AACF;AACEjB,QAAAA,MAAM,CAACW,SAAP,GAAmB,EAAnB,CADF,CAGE;;AACAX,QAAAA,MAAM,CAACP,KAAP,GAAewB,MAAM,GAAG,IAAxB;AAXJ;AAaA;;;AAEA,QAAI,CAACC,QAAL,EAAe;AACblB,MAAAA,MAAM,CAAC0B,aAAP,GAAuB1B,MAAM,CAACsB,WAAP,KAAuB,EAAvB,GAA4B,EAA5B,GAAiC,GAAxD;AAEA,aAAO,EACL,GAAGM,IADE;AAEL5B,QAAAA;AAFK,OAAP;AAID,KA7CqC,CA+CtC;;;AACA,QAAI,CAACJ,WAAW,CAACC,IAAD,EAAOC,KAAP,EAAcC,MAAd,CAAhB,EAAuC;AACrC,aAAO,EACL,GAAG6B,IADE;AAEL5B,QAAAA;AAFK,OAAP;AAID;;AAED,WAAO,EACL,GAAG4B,IADE;AAEL5B,MAAAA,MAAM,EAAEmB,WAAW,CAACnB,MAAD;AAFd,KAAP;AAID,GA3DD;;AA6DA,SAAO,CAAC;AAACD,IAAAA,MAAD;AAAS,OAAGgC;AAAZ,GAAD,KAAyB;AAC9BxB,IAAAA,KAAK,GAAGR,MAAM,CAACiC,MAAP,CAAc1B,QAAQ,CAACT,IAAD,CAAtB,EAA8B,EAAC,GAAGN;AAAJ,KAA9B,CAAR;AAEA,WAAO,wBAAa,EAClB,GAAGwC,MADe;AAElBhC,MAAAA,MAAM,EAAEA,MAAM,CAACkC,GAAP,CAAWN,MAAX;AAFU,KAAb,CAAP;AAID,GAPD;AAQD,CArHD;;eAuHeX,c","sourcesContent":["import {\n  Markers,\n} from 'comment-parser/lib/primitives';\nimport {\n  rewireSource,\n} from 'comment-parser/lib/util';\n\nconst zeroWidth = {\n  name: 0,\n  start: 0,\n  tag: 0,\n  type: 0,\n};\n\nconst shouldAlign = (tags, index, source) => {\n  const tag = source[index].tokens.tag.replace('@', '');\n  const includesTag = tags.includes(tag);\n\n  if (includesTag) {\n    return true;\n  }\n\n  if (tag !== '') {\n    return false;\n  }\n\n  for (let iterator = index; iterator >= 0; iterator--) {\n    const previousTag = source[iterator].tokens.tag.replace('@', '');\n\n    if (previousTag !== '') {\n      if (tags.includes(previousTag)) {\n        return true;\n      }\n\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst getWidth = (tags) => {\n  return (width, {tokens}, index, source) => {\n    if (!shouldAlign(tags, index, source)) {\n      return width;\n    }\n\n    return {\n      name: Math.max(width.name, tokens.name.length),\n      start: tokens.delimiter === Markers.start ? tokens.start.length : width.start,\n      tag: Math.max(width.tag, tokens.tag.length),\n      type: Math.max(width.type, tokens.type.length),\n    };\n  };\n};\n\nconst space = (len) => {\n  return ''.padStart(len, ' ');\n};\n\nconst alignTransform = (tags, indent) => {\n  let intoTags = false;\n  let width;\n\n  const alignTokens = (tokens) => {\n    const nothingAfter = {\n      delim: false,\n      name: false,\n      tag: false,\n      type: false,\n    };\n\n    if (tokens.description === '') {\n      nothingAfter.name = true;\n      tokens.postName = '';\n\n      if (tokens.name === '') {\n        nothingAfter.type = true;\n        tokens.postType = '';\n\n        if (tokens.type === '') {\n          nothingAfter.tag = true;\n          tokens.postTag = '';\n\n          /* istanbul ignore next: Never happens because the !intoTags return. But it's here for consistency with the original align transform */\n          if (tokens.tag === '') {\n            nothingAfter.delim = true;\n          }\n        }\n      }\n    }\n\n    tokens.postDelimiter = nothingAfter.delim ? '' : ' ';\n\n    if (!nothingAfter.tag) {\n      tokens.postTag = space(width.tag - tokens.tag.length + 1);\n    }\n    if (!nothingAfter.type) {\n      tokens.postType = space(width.type - tokens.type.length + 1);\n    }\n    if (!nothingAfter.name) {\n      // If post name is empty for all lines (name width 0), don't add post name spacing.\n      tokens.postName = width.name === 0 ? '' : space(width.name - tokens.name.length + 1);\n    }\n\n    return tokens;\n  };\n\n  const update = (line, index, source) => {\n    const tokens = {...line.tokens};\n    if (tokens.tag !== '') {\n      intoTags = true;\n    }\n\n    const isEmpty =\n      tokens.tag === '' &&\n      tokens.name === '' &&\n      tokens.type === '' &&\n      tokens.description === '';\n\n    // dangling '*/'\n    if (tokens.end === Markers.end && isEmpty) {\n      tokens.start = indent + ' ';\n\n      return {\n        ...line,\n        tokens,\n      };\n    }\n\n    /* eslint-disable indent */\n    switch (tokens.delimiter) {\n      case Markers.start:\n        tokens.start = indent;\n        break;\n      case Markers.delim:\n        tokens.start = indent + ' ';\n        break;\n      default:\n        tokens.delimiter = '';\n\n        // compensate delimiter\n        tokens.start = indent + '  ';\n    }\n    /* eslint-enable */\n\n    if (!intoTags) {\n      tokens.postDelimiter = tokens.description === '' ? '' : ' ';\n\n      return {\n        ...line,\n        tokens,\n      };\n    }\n\n    // Not align.\n    if (!shouldAlign(tags, index, source)) {\n      return {\n        ...line,\n        tokens,\n      };\n    }\n\n    return {\n      ...line,\n      tokens: alignTokens(tokens),\n    };\n  };\n\n  return ({source, ...fields}) => {\n    width = source.reduce(getWidth(tags), {...zeroWidth});\n\n    return rewireSource({\n      ...fields,\n      source: source.map(update),\n    });\n  };\n};\n\nexport default alignTransform;\n"],"file":"alignTransform.js"}